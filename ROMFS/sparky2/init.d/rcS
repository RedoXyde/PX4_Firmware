#!nsh
#
# PX4FMU startup script.
#
#  NOTE: COMMENT LINES ARE REMOVED BEFORE STORED IN ROMFS.
#

#
# Start CDC/ACM serial driver
#
sercon

#
# Default to auto-start mode.
#
set MODE autostart

set TUNE_ERR ML<<CP4CP4CP4CP4CP4
# set to /dev/null to get the NuttX shell through USB
set LOG_FILE /dev/null

#
# Start the ORB (first app to start)
#
uorb start

#
# Load parameters
#
set PARAM_FILE none
if mtd start
then
	set PARAM_FILE /fs/mtd_params
fi

param select $PARAM_FILE
if param load
then
else
	if param reset
	then
	fi
fi

#
# Start system state indicator
#
#if rgbled start
#then
#else
#	if blinkm start
#	then
#		blinkm systemstate
#	fi
#fi

# Currently unused, but might be useful down the road
#if pca8574 start
#then
#fi

#
# Set AUTOCNF flag to use it in AUTOSTART scripts
#
if param compare SYS_AUTOCONFIG 1
then
	# Wipe out params except RC*
	param reset_nostart RC*
	set AUTOCNF yes
else
	set AUTOCNF no
fi

#
# Set default values
#
set HIL no
set VEHICLE_TYPE none
set MIXER none
set MIXER_AUX none
set OUTPUT_MODE none
set PWM_OUT none
set PWM_RATE none
set PWM_DISARMED none
set PWM_MIN none
set PWM_MAX none
set PWM_AUX_OUT none
set PWM_AUX_RATE none
set PWM_ACHDIS none
set PWM_AUX_DISARMED none
set PWM_AUX_MIN none
set PWM_AUX_MAX none
set MK_MODE none
set FMU_MODE pwm
set MAVLINK_F default
set EXIT_ON_END no
set MAV_TYPE none
set FAILSAFE none

#
# Set USE_IO flag
#
set USE_IO no

#
# Set parameters and env variables for selected AUTOSTART
#
if param compare SYS_AUTOSTART 0
then
	echo "[i] No autostart"
else
	sh /etc/init.d/rc.autostart
fi
unset MODE

#
# Wipe incompatible settings for boards not having two outputs
set MIXER_AUX none


#
# Override parameters from user configuration file
#
set FCONFIG /etc/config.txt
if [ -f $FCONFIG ]
then
	echo "[i] Custom: $FCONFIG"
	sh $FCONFIG
fi
unset FCONFIG

#
# If autoconfig parameter was set, reset it and save parameters
#
if [ $AUTOCNF == yes ]
then
	param set SYS_AUTOCONFIG 0
	param save
fi
unset AUTOCNF

set IO_PRESENT no

#
# Set default output if not set
#
if [ $OUTPUT_MODE == none ]
then
	set OUTPUT_MODE fmu
fi

if [ $HIL == yes ]
then
	set OUTPUT_MODE hil
#	if ver hwcmp PX4FMU_V1
#	then
#		set FMU_MODE serial
#	fi
	unset HIL
else
	unset HIL
	gps start
fi

# waypoint storage
# REBOOTWORK this needs to start in parallel
if dataman start -f /fs/mtd_dataman
then
fi

#
# Sensors System (start before Commander so Preflight checks are properly run)
#
sh /etc/init.d/rc.sensors

# Needs to be this early for in-air-restarts
if [ $OUTPUT_MODE == hil ]
then
    commander start -hil
else
    commander start
fi

#
# Start primary output
#
set TTYS1_BUSY no

#
# Check if UAVCAN is enabled, default to it for ESCs
#
if param greater UAVCAN_ENABLE 2
then
	set OUTPUT_MODE uavcan_esc
fi

# If OUTPUT_MODE == none then something is wrong with setup and we shouldn't try to enable output
if [ $OUTPUT_MODE != none ]
then
	if [ $OUTPUT_MODE == uavcan_esc ]
	then
		if param compare UAVCAN_ENABLE 0
		then
			echo "[i] OVERRIDING UAVCAN_ENABLE = 1"
			param set UAVCAN_ENABLE 1
		fi
	fi

	if [ $OUTPUT_MODE == fmu ]
	then
		if fmu mode_$FMU_MODE
		then
		else
			echo "FMU start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
	fi

	if [ $OUTPUT_MODE == mkblctrl ]
	then
		set MKBLCTRL_ARG ""
		if [ $MKBLCTRL_MODE == x ]
		then
			set MKBLCTRL_ARG "-mkmode x"
		fi
		if [ $MKBLCTRL_MODE == + ]
		then
			set MKBLCTRL_ARG "-mkmode +"
		fi

		if mkblctrl $MKBLCTRL_ARG
		then
		else
			echo "ERROR: MK start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
		unset MKBLCTRL_ARG
	fi
	unset MK_MODE

	if [ $OUTPUT_MODE == hil ]
	then
		if pwm_out_sim mode_port2_pwm8
		then
		else
			echo "PWM SIM start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
	fi

	#
	# Start IO or FMU for RC PPM input if needed
	#
	if [ $OUTPUT_MODE != fmu ]
	then
		if fmu mode_$FMU_MODE
		then
		else
			echo "FMU mode_$FMU_MODE start failed" >> $LOG_FILE
			tone_alarm $TUNE_ERR
		fi
	fi
fi

if [ $MAVLINK_F == default ]
then
	# Normal mode, use baudrate 57600 (default) and data rate 1000 bytes/s
	if [ $TTYS1_BUSY == yes ]
	then
		# Start MAVLink on ttyS0, because FMU ttyS1 pins configured as something else
		set MAVLINK_F "-r 1200 -d /dev/ttyS0"

		# Exit from nsh to free port for mavlink
		set EXIT_ON_END yes
	else
		set MAVLINK_F "-r 1200"
		# Avoid using ttyS1 for MAVLink on FMUv4
		if ver hwcmp PX4FMU_V4
		then
			set MAVLINK_F "-r 1200 -d /dev/ttyS1"
			# Start MAVLink on Wifi (ESP8266 port)
			mavlink start -r 20000 -m config -b 921600 -d /dev/ttyS0
		fi
	fi
fi

mavlink start $MAVLINK_F
unset MAVLINK_F

#
# MAVLink onboard / TELEM2
#
# XXX We need a better way for runtime eval of shell variables,
# but this works for now
if param compare SYS_COMPANION 10
then
	frsky_telemetry start -d /dev/ttyS2
fi
if param compare SYS_COMPANION 921600
then
	mavlink start -d /dev/ttyS2 -b 921600 -m onboard -r 80000 -x
fi
if param compare SYS_COMPANION 57600
then
	mavlink start -d /dev/ttyS2 -b 57600 -m onboard -r 5000 -x
fi
if param compare SYS_COMPANION 157600
then
	mavlink start -d /dev/ttyS2 -b 57600 -m osd -r 1000
fi
if param compare SYS_COMPANION 257600
then
	mavlink start -d /dev/ttyS2 -b 57600 -m magic -r 5000 -x
fi
if param compare SYS_COMPANION 357600
then
	mavlink start -d /dev/ttyS2 -b 57600 -r 1000
fi
if param compare SYS_COMPANION 1921600
then
	mavlink start -d /dev/ttyS2 -b 921600 -r 20000
fi

# Sensors on the PWM interface bank
# clear pins 5 and 6
if param compare SENS_EN_LL40LS 1
then
	set AUX_MODE pwm4
fi
if param greater TRIG_MODE 0
then
	# Get FMU driver out of the way
	set MIXER_AUX none
	set AUX_MODE none
	camera_trigger start
fi

# Transitional support: Disable safety on all Sparky2 boards
if ver hwcmp SPARKY2
then
	if param set CBRK_IO_SAFETY 22027
	then
	fi
fi

#
# Starting stuff according to UAVCAN_ENABLE value
#
if param greater UAVCAN_ENABLE 0
then
	if uavcan start
	then
	else
		tone_alarm $TUNE_ERR
	fi
fi

if param greater UAVCAN_ENABLE 1
then
	if uavcan start fw
	then
	else
		tone_alarm $TUNE_ERR
	fi
fi

#
# Optional drivers
#

#if ver hwcmp PX4FMU_V4
#then
#	frsky_telemetry start -d /dev/ttyS6
#fi

#if ver hwcmp PX4FMU_V2
#then
#	# Check for flow sensor - as it is a background task, launch it last
#	px4flow start &
#fi

# Start USB shell if no microSD present, MAVLink else
if [ $LOG_FILE == /dev/null ]
then
	# Try to get an USB console
	nshterm /dev/ttyACM0 &
else
	mavlink start -r 800000 -d /dev/ttyACM0 -m config -x
fi

#
# Multicopters setup
#
if [ $VEHICLE_TYPE == mc ]
then
	echo "MULTICOPTER"

	if [ $MIXER == none ]
	then
		echo "Mixer undefined"
	fi

	if [ $MAV_TYPE == none ]
	then
		# Use mixer to detect vehicle type
		if [ $MIXER == quad_x -o $MIXER == quad_+ ]
		then
			set MAV_TYPE 2
		fi
		if [ $MIXER == quad_h ]
		then
			set MAV_TYPE 2
		fi
	fi

	# Still no MAV_TYPE found
	if [ $MAV_TYPE == none ]
	then
		echo "Unknown MAV_TYPE"
		param set MAV_TYPE 2
	else
		param set MAV_TYPE $MAV_TYPE
	fi

	# Load mixer and configure outputs
	sh /etc/init.d/rc.interface

	# Start standard multicopter apps
	sh /etc/init.d/rc.mc_apps
fi

unset MIXER
unset MAV_TYPE
unset OUTPUT_MODE

#
# Start the navigator
#
#navigator start

#
# Generic setup (autostart ID not found)
#
if [ $VEHICLE_TYPE == none ]
then
	echo "[i] No autostart ID found"
fi

# There is no further script processing, so we can free some RAM
# XXX potentially unset all script variables.
unset TUNE_ERR

# Boot is complete, inform MAVLink app(s) that the system is now fully up and running
mavlink boot_complete

if [ $EXIT_ON_END == yes ]
then
	echo "NSH EXIT"
	exit
fi
unset EXIT_ON_END
